# -*- coding: utf-8 -*-
"""Exercícios codeq.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xU2F19Pfd5lPSDypvp9KR5sA-AOT5Ygw

# 1.

Leia 2 valores inteiros e armazene-os nas variáveis **A** e **B**. Efetue a soma de **A** e **B** atribuindo o seu resultado na variável **X**. Imprima **X** conforme exemplo apresentado abaixo.

## **Entrada**

A entrada contém 2 valores inteiros.

## **Saída**

Imprima a mensagem "X = " (letra X maiúscula) seguido pelo valor da variável **X** e pelo final de linha. Cuide para ter um espaço antes e depois do sinal de igualdade, conforme o exemplo abaixo.

10

4            

X = 14
"""

A = int(input())
B = int(input())
X = (A + B)
print("X =", X)

"""# 2.

A fórmula para calcular a área de uma circunferência é: **area = π . raio2**. Considerando para este problema que **π =** 3.14159:

- Efetue o cálculo da área, elevando o valor de **raio** ao quadrado e multiplicando por **π**.

## **Entrada**

A entrada contém um valor de ponto flutuante (dupla precisão), no caso, a variável **raio.**

## **Saída**

Apresentar a mensagem "A = " seguido pelo valor da variável **area**, conforme exemplo abaixo, com 4 casas após o ponto decimal. Utilize variáveis de dupla precisão (double).

2

A = 12.5664
"""

pi = 3.14159
raio = float(input())
area = pi*raio**2
A = area
print("A =", round(A, 4))

"""# 3.

Leia 3 valores, no caso, variáveis A, B e C, que são as três notas de um aluno. A seguir, calcule a média do aluno, sabendo que a nota A tem peso 2, a nota B tem peso 3 e a nota C tem peso 5. Considere que cada nota pode ir de 0 até 10.0, sempre com uma casa decimal.
## **Entrada**

O arquivo de entrada contém 3 valores com uma casa decimal, de dupla precisão (double).
## **Saída**

Imprima a mensagem "MEDIA = " e a média do aluno conforme exemplo abaixo, com 1 dígito após o ponto decimal e com um espaço em branco antes e depois da igualdade.

5.0

6.0

7.0

MEDIA = 6.3
"""

nota_A = float(input("Nota aluno A: "))
nota_B = float(input("Nota aluno B: "))
nota_C = float(input("Nota aluno C: "))

peso_nota_A = 2.0
peso_nota_B = 3.0
peso_nota_C = 5.0

MEDIA = ((nota_A*peso_nota_A) + (nota_B*peso_nota_B) + (nota_C*peso_nota_C))/ (peso_nota_A + peso_nota_B + peso_nota_C)
print("MEDIA =", round(MEDIA, 1))

"""# 4.

Escreva um programa que leia três valores com ponto flutuante de dupla precisão: A, B e C. Em seguida, calcule e mostre:

a) a área do triângulo retângulo que tem A por base e C por altura.

b) a área do círculo de raio C. (pi = 3.14159)

c) a área do trapézio que tem A e B por bases e C por altura.

d) a área do quadrado que tem lado B.

e) a área do retângulo que tem lados A e B.

## **Entrada**

O arquivo de entrada contém três valores com um dígito após o ponto decimal.

## **Saída**

O arquivo de saída deverá conter 5 linhas de dados. Cada linha corresponde a uma das áreas descritas acima, sempre com mensagem correspondente e um espaço entre os dois pontos e o valor. O valor calculado deve ser apresentado com 3 dígitos após o ponto decimal.

3.0 4.0 5.2

TRIANGULO: 7.800

CIRCULO: 84.949

TRAPEZIO: 18.200

QUADRADO: 16.000

RETANGULO: 12.000
"""

A, B, C = map(float, input().split())
 
pi = 3.14159

area_triangulo = (A * C)/2
area_circulo = (pi * C**2)
area_trapezio = ((A + B)*C)/2
area_quadrado = (B * B)
area_retangulo = (A * B)

print("TRIANGULO: %.3f" % area_triangulo)
print("CIRCULO: %.3f" % area_circulo)
print("TRAPEZIO: %.3f" % area_trapezio)
print("QUADRADO: %.3f" % area_quadrado)
print("RETANGULO: %.3f" % area_retangulo)

"""# 5.

Leia os quatro valores correspondentes aos eixos x e y de dois pontos quaisquer no plano, p1(x1,y1) e p2(x2,y2) e calcule a distância entre eles, mostrando 4 casas decimais após a vírgula.
## **Entrada**

O arquivo de entrada contém duas linhas de dados. A primeira linha contém dois valores de ponto flutuante: ***x1 y1*** e a segunda linha contém dois valores de ponto flutuante ***x2 y2.***
## **Saída**

Calcule e imprima o valor da distância segundo a fórmula fornecida, com 4 casas após o ponto decimal.

1.0  7.0

5.0  9.0

4.4721
"""

import math

x1, y1 = map(float, input().split())
x2, y2 = map(float, input().split())

distancia = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
print(round(distancia, 4))

"""# 6.

Escreva um programa que leia o número de um funcionário, seu número de horas trabalhadas, o valor que recebe por hora e calcula o salário desse funcionário. A seguir, mostre o número e o salário do funcionário, com duas casas decimais.

## **Entrada**

O arquivo de entrada contém 2 números inteiros e 1 número com duas casas decimais, representando o número, quantidade de horas trabalhadas e o valor que o funcionário recebe por hora trabalhada, respectivamente.

## **Saída**

Imprima o número e o salário do funcionário, conforme exemplo fornecido, com um espaço em branco antes e depois da igualdade. No caso do salário, também deve haver um espaço em branco após o $.

25

100

5.50

NUMBER = 25

SALARY = U$ 550.00
"""

num_funcionario = float(input())
horas_trabalhadas = float(input())
valor_hora = float(input())

salario = horas_trabalhadas * valor_hora
print("NUMBER = %.0f" % num_funcionario)
print("SALARY = U$ %.2f" %salario)

"""# 7.

Leia um valor inteiro correspondente à idade de uma pessoa em dias e informe-a em anos, meses e dias

Obs.: apenas para facilitar o cálculo, considere todo ano com 365 dias e todo mês com 30 dias. Nos casos de teste nunca haverá uma situação que permite 12 meses e alguns dias, como 360, 363 ou 364. Este é apenas um exercício com objetivo de testar raciocínio matemático simples.

Dica: pesquise pela operação de módulo ou resto

## **Entrada**

O arquivo de entrada contém um valor inteiro.

## **Saída**

Imprima a saída conforme exemplo fornecido.

800

2 ano(s)

2 mes(es)

10 dia(s)

"""

idade = int(input())

idade_em_anos = idade // 365
idade = idade % 365
idade_em_meses = idade // 30
idade = idade % 30 
idade_em_dias = idade

print(idade_em_anos, "ano(s)")
print(idade_em_meses, "mes(es)")
print(idade_em_dias, "dia(s)")

"""# 8.

Leia 3 valores de ponto flutuante e efetue o cálculo das raízes da equação de Bhaskara. Se não for possível calcular as raízes, mostre a mensagem correspondente *“Impossivel calcular”*, caso haja uma divisão por 0 ou raiz de numero negativo.

## **Entrada**

Leia três valores de ponto flutuante (double) A, B e C.

## **Saída**

Se não houver possibilidade de calcular as raízes, apresente a mensagem "Impossivel calcular". Caso contrário, imprima o resultado das raízes com 5 dígitos após o ponto, com uma mensagem correspondente conforme exemplo abaixo. Imprima sempre o final de linha após cada mensagem.

10.0 20.1 5.1  

R1 = -0.29788

R2 = -1.71212

0.0 20.0 5.0

Impossivel calcular
"""

import math

A, B, C = map(float, input().split())

delta = B**2 - 4*A*C

if delta <=0 or A==0:
  print("Impossível calcular")
else:
  x1 = (-B + math.sqrt(delta)) / (2*A)
  x2 = (-B - math.sqrt(delta)) / (2*A)

  print("R1 =", round(x1, 5))
  print("R2 =", round(x2, 5))

"""# 9.

Leia um número inteiro que representa um código de DDD para discagem interurbana. Em seguida, informe à qual cidade o DDD pertence, considerando a tabela abaixo:

| DDD | Destino |
| --- | --- |
| 61 | Brasília |
| 71 | Salvador |
| 11 | São Paulo |
| 21 | Rio de Janeiro |
| 32 | Juiz de Fora |
| 19 | Campinas |
| 27 | Vitória |
| 31 | Belo Horizonte |
| 55 | Santa Maria |

Se a entrada for qualquer outro DDD que não esteja presente na tabela acima, o programa deverá informar: `DDD não cadastrado`

## **Entrada**

A entrada consiste de um único valor inteiro.

## **Saída**

Imprima o nome da cidade correspondente ao DDD existente na entrada. Imprima *DDD nao cadastrado*
 caso não existir DDD correspondente ao número digitado.

11

São Paulo
"""

DDD = int(input())

tabela_cidades = {
    61: "Brasília",
    71: "Salvador",
    11: "São Paulo",
    21: "Rio de Janeiro",
    32: "Juiz de Fora",
    19: "Campinas",
    27: "Vitória",
    31: "Belo Horizonte",
    55: "Santa Maria"
}

if DDD in tabela_cidades:
  print (tabela_cidades[DDD])
else:
  print("DDD não cadastrado")

"""# 10.

A Federação Gaúcha de Futebol contratou você para escrever um programa para fazer uma estatística do resultado de vários GRENAIS. Escreva um programa para ler o número de gols marcados pelo Inter e pelo Grêmio em um GRENAL. Logo após escrever a mensagem "Novo grenal (1-sim 2-nao)" e solicitar uma resposta. Se a resposta for 1, o algoritmo deve ser executado novamente solicitando o número de gols marcados pelos times em uma nova partida, caso contrário deve ser encerrado imprimindo:

- Quantos GRENAIS fizeram parte da estatística.
- O número de vitórias do Inter.
- O número de vitórias do Grêmio.
- O número de Empates.
- Uma mensagem indicando qual o time que venceu o maior número de GRENAIS (ou "Nao houve vencedor", caso termine empatado).

## **Entrada**

O arquivo de entrada contém 2 valores inteiros, correspondentes aos gols marcados pelo Inter e pelo Grêmio respectivamente. Em seguida háverá um inteiro (1 ou 2), correspondente à repetição do programa.

## **Saída**

Após cada leitura dos gols, deve ser impressa a mensagem "Novo grenal (1-sim 2-nao)". Quando o algoritmo for encerrado devem ser mostradas as estatísticas conforme a descrição apresentada acima. Obs: a palavra "Gremio" deve ser impressa sem acento, conforme o exemplo abaixo.

3 2

1

2 3

1

3 1

2

Novo grenal (1-sim 2-nao)

Novo grenal (1-sim 2-nao)

Novo grenal (1-sim 2-nao)

3 grenais

Inter:2

Gremio:1

Empates:0

Inter venceu mais

"""

INT_V = 0
GRE_V = 0
E = 0
total_grenais = 0

while True:
    INT_gols, GRE_gols = map(int, input().split())

    if INT_gols > GRE_gols:
        INT_V += 1
    elif GRE_gols > INT_gols:
        GRE_V += 1
    else:
        E += 1

    total_grenais += 1

    novo_grenal = int(input("Novo grenal (1 - sim 2 - nao)\n"))

    if novo_grenal == 2:
        break

print(f"{total_grenais} grenais\n"
      f"Inter: {INT_V}\n"
      f"Gremio: {GRE_V}\n"
      f"Empates: {E}")

if INT_V > GRE_V:
    print("Inter venceu mais")
elif GRE_V > INT_V:
    print("Gremio venceu mais")
else:
    print("Nao houve vencedor")

"""# 11.

Em cada fase do jogo do Pula Sapo você deve conduzir seu anfíbio através de uma sequência de canos de alturas diferentes até chegar a salvo no cano mais à direita. Entretanto, o sapo só consegue sobreviver se a diferença de altura entre canos consecutivos for de, no máximo, a altura do pulo do sapo. Caso a altura do cano seguinte seja muito alta, o sapo bate no cano e cai. Se a altura do cano seguinte for muito baixa, o sapo não aguenta a queda. O sapo sempre começa em cima do cano mais à esquerda.

Neste jogo, a distância entre os canos é irrelevante, ou seja, o sapo sempre consegue alcançar o próximo cano com um pulo.

Você deve escrever um programa que, dadas as alturas dos canos e a altura do pulo do sapo, mostra se a fase do jogo pode ser vencida ou não.

## **Entrada**

A entrada é dada em duas linhas. A primeira tem dois inteiros positivos **P** e **N**, a altura do pulo do sapo e o número de canos (1 ≤ **P** ≤ 5 e 2 ≤ **N** ≤ 100). A segunda linha tem **N** inteiros positivos que indicam as alturas dos canos ordenados da esquerda para a direita. Não há altura maior do que 10.

## **Saída**

A saída é dada em uma única linha. Se o sapo pode chegar no cano mais à direita, escreva "YOU WIN". Se o sapo não consegue, escreva "GAME OVER".

5 10

1 3 6 9 7 2 4 5 8 3


1 2

2 2



1 2

1 3

YOU WIN



YOU WIN



GAME OVER
"""

P, N = map(int, input().split())

altura = list(map(int, input().split()))

primeiro_cano = 0

for i in range(1, N):
    if abs(altura[i] - altura[primeiro_cano]) > P:
        print("GAME OVER")
        break
    else:
        primeiro_cano = i
else:
    print("YOU WIN")

"""# 12.

Degustação de chá às escuras é a habilidade de identificar um chá usando apenas seus sentidos do olfato e paladar. Isto faz parte da Competição Ideal de Consumidores de Chá Puro (da sigla em inglês ICPC), que um programa de TV local está organizando. Durante o show, um bule de chá completo é preparado e são entregues uma xícara de chá para cada um dos cinco competidores. Os participantes devem cheirar, saborear e avaliar a amostra, de modo a identificar o tipo de chá, que pode ser: (1) o chá branco; (2) chá verde; (3) chá preto; ou (4) chá de ervas. No final, as respostas são verificadas para determinar o número de suposições corretas. Dado o tipo de chá real e as respostas fornecidas, determinar o número de participantes que receberam a resposta correta.

## **Entrada**

A primeira linha contém um inteiro **T** representando o tipo de chá (1 ≤ **T** ≤ 4). A segunda linha contém cinco inteiros **A, B, C, D** e **E**, que indica a resposta dada por cada competidor (1 ≤ **A, B, C, D, E** ≤ 4).

## **Saída**

A saída contém um inteiro representando o número de concorrentes que obtiveram a resposta correta.

1

1 2 3 2 1

2
"""

T = int(input())
respostas = list(map(int, input().split()))
respostas_corretas = respostas.count(T)

print(respostas_corretas)

"""# 13.

Ao observar a paisagem da Nlogônia, o professor MC percebeu que a cada intervalo de 100 metros existe um pico. E que exatamente na metade de dois picos há um vale. Logo, a cada 50 metros há um vale ou um pico e, ao longo da paisagem, não há um pico seguido por outro pico, nem um vale seguido por outro vale.

O professor MC ficou curioso com esse padrão e quer saber se, ao medir outras paisagens, isso se repete. Sua tarefa é, dada uma paisagem, indicar se ela possui esse padrão ou não.

## **Entrada**

A entrada é dada em duas linhas. A primeira tem o número **N** de medidas da paisagem (1 < **N** ≤ 100). A segunda linha tem **N** inteiros: a altura **Hi** de cada medida (-10000 ≤ **Hi** ≤ 10000, para todo **Hi**, tal que 1 ≤ **i** ≤ **N**). Uma medida é considerada um pico se é maior que a medida anterior. Uma medida é considerada um vale se é menor que a medida anterior.

## **Saída**

A saída é dada em uma única linha. Caso a paisagem tenha o mesmo padrão da Nlogônia, deve ser mostrado o número 1. Caso contrário, mostra-se o número 0.

3

1 4 -2

5

100 99 112 -8 -7

4

1 2 2 1

1


1


0
"""



"""# 14.

*Analógimôn Go!* é um jogo bastante popular. Os jogadores de *Analógimôn Go!* são divididos em três grandes times: Time Valor, Time Instinto e Time Místico, que são liderados pelos seus líderes Kandera, Esparky e Blanque, respectivamente. Naturalmente, você faz parte de um desses times!

O líder do seu time está sendo acusado de infringir as regras do jogo por gerenciar incorretamente os doces recebidos do Professor que são destinados ao time. Isto criou uma grande polêmica dentro da equipe: alguns jogadores defendem que o líder realmente agiu incorretamente e deve sofrer um *impeachment* e ser afastado de seu cargo, enquanto outros defendem que ele não infringiu as regras, que a acusação é inverídica e que ele deve continuar no cargo.

Para resolver a situação, uma votação será realizada entre todos os **N** jogadores do seu time. Cada jogador deverá votar se o *impeachment* deve ou não ocorrer. Se o número de votos favoráveis ao *impeachment* foi maior ou igual a 2/3 (dois terços) do total de jogadores, o líder será afastado. Caso contrário, a acusação é arquivada e ele continuará no cargo.

Dados os votos de todos os jogadores, determine o resultado da votação.

## **Entrada**

A entrada contém vários casos de teste. A primeira linha de cada caso contém o inteiro **N** (1 ≤ **N** ≤ 105), o número de jogadores em seu time. A próxima linha contém **N** inteiros **v1**, ..., **vN** (**vi** = 0 ou 1), indicando os votos dos jogadores. O valor 1 indica um voto favorável ao *impeachment*, enquanto o valor 0 indica um voto contrário ao mesmo.

A entrada termina com fim-de-arquivo (EOF).

## **Saída**

Para cada caso de teste, imprima uma linha contendo a palavra *impeachment* se o líder deve ser afastado de seu cargo, ou *acusação arquivada* caso contrário.

6

1 0 1 1 0 1


5

0 1 1 1 0

impeachment



acusacao arquivada
"""

while True:
    try:
        N = int(input())
        votos_jogadores = input().split()
        voto_favoravel = votos_jogadores.count('1')
        if voto_favoravel >= 2*N/3:
            print("impeachment")
        else:
            print("acusacao arquivada")
    except EOFError:
        break

"""# 15.

System of a Download é uma famosa banda de Hacker Metal! Certa vez, eles criaram um dispositivo, com seis botões, numerados de 0 a 5, e colocaram nesse dispositivo os seus 11 maiores sucessos. Para tocar uma destas músicas, é preciso pressionar dois botões. Com isso, os números destes dois botões são somados, e então toca-se a música correspondente ao número da soma, conforme a relação abaixo:

0 - PROXYCITY1 - P.Y.N.G.2 - DNSUEY!3 - SERVERS4 - HOST!5 - CRIPTONIZE6 - OFFLINE DAY7 - SALT8 - ANSWER!9 - RAR?10 - WIFI ANTENNAS

Por exemplo, se os botões pressionados forem 3 e 4, irá tocar a música 7 - SALTEscreva um programa que, dados os dois botões que forem pressionados, determine qual música irá tocar.

## **Entrada**

Um número inteiro **C** será informado, que será a quantidade de casos de teste. Cada caso tem dois valores inteiros, **X** e **Y**, representando quais botões foram pressionados.

## **Saída**

Para cada caso de teste, imprima o nome da música correspondente.

3

3 4

0 0

1 0

SALT

PROXYCITY

P.Y.N.G.
"""

musicas = ["PROXYCITY","P.Y.N.G.","DNSUEY!","SERVERS","HOST!","CRIPTONIZE","OFFLINE DAY","SALT","ANSWER!","RAR?","WIFI ANTENNAS"]

C  = int(input())

for i in range(C):
    X, Y = map(int, input().split())
    C = X + Y
    print(musicas[C])

"""# 16.

Para descontrair os alunos após as provas da OBI, a Diretora da escola organizou um campeonato de aviões de papel. Cada aluno participante receberá uma certa quantidade de folhas de um papel especial para fazer os seus modelos de aviões. A quantidade de folhas que cada aluno deverá receber ainda não foi determinada: ela será decidida pelos juízes do campeonato.

A diretora convidou, para atuarem como juízes, engenheiros da Embraer, uma das mais bem sucedidas empresas brasileiras, que vende aviões com tecnologia brasileira no mundo todo. O campeonato está programado para começar logo após a prova da OBI, mas os juízes ainda não chegaram à escola. A diretora está aflita, pois comprou uma boa quantidade de folhas de papel especial, mas não sabe se a quantidade comprada vai ser suficiente.

Considere, por exemplo, que a Diretora comprou 100 folhas de papel especial, e que há 33 competidores. Se os juízes decidirem que cada competidor tem direito a três folhas de papel, a quantidade comprada pela diretora é suficiente. Mas se os juízes decidirem que cada competidor tem direito a quatro folhas, a quantidade comprada pela diretora não seria suficiente.

Você deve escrever um programa que, dados o número de competidores, o número de folhas de papel especial compradas pela Diretora e o número de folhas que cada competidor deve receber, determine se o número de folhas comprado pela Diretora é suficiente.

## **Entrada**

A entrada contém um único conjunto de testes, que deve ser lido do dispositivo de entrada padrão (normalmente o teclado). O arquivo de entrada contém três números inteiros **C** (1 ≤ **C** ≤ 1000), **P** (1 ≤ **P** ≤ 1000) e **F** (1 ≤ **F** ≤ 1000) representando respectivamente o número de competidores, a quantidade de folhas de papel especial compradas pela Diretora e a quantidade de folhas de papel especial que cada competidor deve receber.

## **Saída**

Seu programa deve imprimir, na saída padrão, o caractere ‘S’ se a quantidade de folhas compradas pela Diretora é suficiente, ou o caractere ‘N’ caso contrário. Note que os caracteres devem ser letras maiúsculas.

10 100 10

10 90 10

5 40 2

S

N

S
"""

C, P, F = map(int, input().split())

F = C * P

if F <= P:
    print('S')
else:
    print('N')

"""# 17.

Um novo jogo chamado Ímpar, Par ou Roubo (IPR) está se tornando muito popular. Esse jogo surgiu quando alguns amigos estavam sem conexão com a internet, sem celular, sem computador e bastante desocupados. O jogo está tão popular que irá acontecer um campeonato mundial de IPR e cada país do mundo irá escolher um representante para competir.

O jogo funciona da seguinte forma: dois jogadores participam, o jogador 1 escolhe entre par ou ímpar, então cada jogador escolhe um inteiro positivo, se a soma desses números for par e o jogador 1 tiver escolhido par então o jogador 1 ganha, se a soma for ímpar o jogador 2 ganha. Caso o jogador 1 tivesse escolhido ímpar ele ganharia se a soma fosse ímpar, caso a soma fosse par o jogador 2 ganharia. Nada de diferente de um jogo de par ou ímpar convencional, correto?

A diferença do jogo é que o jogador 1 pode roubar e assim assegurar sua vitória independentemente do resultado do jogo de ímpar ou par convencional, já o jogador 2 pode ou não acusar o jogador 1 de roubo. Com essas adições no jogo se o jogador 1 roubar e o jogador 2 acusar o roubo então o jogador 2 ganha, caso o jogador 2 não acuse o roubo e o jogador 1 roubar então o jogador 1 ganha, caso o jogador 2 acuse o roubo, mas o jogador 1 não tiver roubado então o jogador 1 ganha, se o jogador 1 não roubar e o jogador 2 não acusar o roubo o jogo segue como descrito anteriormente.

Você foi contratado pela OIIPR (Organização Internacional de Ímpar, Par ou Roubo) para desenvolver um programa que dada a escolha do jogador 1 entre par ou ímpar, os números escolhidos como jogada e as ações dos jogadores (roubo/acusação) mostre quem foi o vencedor.

## **Entrada**

A entrada consite de uma única linha contendo 5 inteiros: **p**, **j1**, **j2**, **r**, **a**. ( 0 ≤ **p, r, a** ≤ 1 e 1 ≤ **j1**, **j2** ≤ 100).

**p** representa a escolha do jogador 1 (se **p** = 1 então o jogador 1 escolheu par, se **p** = 0 então o jogador 1 escolheu ímpar). Os valores **j1**, **j2**, representam respectivamente o número escolhido pelo jogador 1 e pelo jogador 2. **r** representa se o jogador 1 roubou (se **r** = 1 então o jogador 1 roubou, se **r** = 0 então o jogador 1 não roubou), **a** representa se o jogador 2 acusou o roubo (se **a** = 1 então o jogador 2 acusou o jogador 1 de roubo, se **a** = 0 então ele não acusou o jogador 1 de roubo).

## **Saída**

Imprima "Jogador 1 ganha!" se o jogador 1 ganhou ou "Jogador 2 ganha!" se o jogador 2 ganhou (sem as aspas).

1 4 5 0 

1 4 5 1 0

1 4 5 1 1
"""

p, j1, j2, r, a = map(int, input().split())

soma = j1 + j2
paridade_soma = soma % 2

if r == 0:
    if p == paridade_soma:
        print("Jogador 1 ganha!")
    else:
        print("Jogador 2 ganha!")
else:
    if a == 0:
        print("Jogador 1 ganha!")
    else:
        print("Jogador 2 ganha!")

"""# 18.

Amélia ama o Natal, e sua parte favorita nesta data é montar a árvore de natal! Ela adora decorar a árvore com bolinhas e luzes coloridas, para que ela fique brilhante e divertida! Porém, Amélia gosta das coisas bem distribuídas e exige que sua árvore não tenha mais que a metade de galhos em bolinhas. Assim, se sua árvore de natal tem **G** galhos, ela precisa ***G**/2* bolinhas. Se o número **G** de galhos for ímpar, esse valor será arredondado para baixo.

Neste ano, Amélia resolveu atualizar sua árvore e irá comprar uma nova. Além disso, algumas de suas bolinhas quebraram, e ela vai precisar saber quantas novas bolinhas vai precisar comprar para manter sua árvore equilibrada do jeito que gosta!

Para isso, ela quer sua ajuda! Dada a quantidade de bolinhas que Amélia tem e a quantidade de galhos que sua nova árvore terá, diga para Amélia quantas bolinhas de natal ela precisa comprar para decorar sua nova árvore!

## **Entrada**

A entrada consiste de dois valores inteiros, lidos em duas linhas, **B** (1 < **B** < 103) e **G** (100 < **G** < 1000) que indicam, respectivamente, a quantidade de bolinhas que Amélia já possui e a quantidade de galhos de sua nova árvore de natal.

## **Saída**

Imprima a quantidade de bolinhas que Amélia precisa comprar para completar sua árvore, com a mensagem "Faltam **B** bolinha(s)", onde **B** é a quantidade de bolinhas que Amelia precisa comprar. Caso Amelia possua bolinhas suficientes ou de sobra, imprima a mensagem "Amelia tem todas bolinhas!"

300

700

300

600

300

701

Faltam 50 bolinha(s)


Amelia tem todas bolinhas!


Faltam 50 bolinha(s)
"""

B = int(input())
G = int(input())

bolinhas_que_faltam = G//2 - B

if B < G//2:
    print("Faltam", bolinhas_que_faltam, "bolinha(s)")
else:
    print("Amelia tem todas bolinhas!")

"""# 19.

Dados dois números inteiros, n e m, quantos dígitos tem  $n^m$?

Exemplos:

2 e 10 → $2^{10}$ = 1024 - 4 dígitos

3 e 9 → $3^9$ = 19683 - 5 dígitos

## **Entrada**

A entrada é composta por vários casos de teste. A primeira linha tem um número inteiro **C**, representando a quantidade de casos de teste. As **C** linhas seguintes contém dois números inteiros **N** e **M** (1 <= **N**, **M** <= 100).

## **Saída**

Para cada caso de teste de entrada do seu programa, você deve imprimir um número inteiro contendo a quantidade de dígitos do resultado da potência calculada no respectivo caso de teste.

4

1 1

2 10

3 9

100 100

1

4

5

201
"""

import math

C = int(input())

for i in range(C):
    N, M = map(int, input().split())

    qtd_digitos = math.floor(M * math.log10(N)) + 1

    print(qtd_digitos)

"""# 20.

A organização da OIBR, Olimpíada Internacional de Basquete de Robô, está começando a ter problemas com dois times: os Bit Warriors e os Byte Bulls. É que os robôs desses times acertam quase todos os lançamentos, de qualquer posição na quadra! Pensando bem, o jogo de basquete ficaria mesmo sem graça se jogadores conseguissem acertar qualquer lançamento, não é mesmo? Uma das medidas que a OIBR está implantando é uma nova pontuação para os lançamentos, de acordo com a distância do robô para o início da quadra. A quadra tem 2000 centímetros de comprimento, como na figura.

![https://resources.beecrowd.com.br/gallery/images/problems/UOJ_2780.png](https://resources.beecrowd.com.br/gallery/images/problems/UOJ_2780.png)


Dada a distância D do robô até o início da quadra, onde está a cesta, a regra é a seguinte:

- Se **D** ≤ 800, a cesta vale 1 ponto;
- Se 800 < **D** ≤ 1400, a cesta vale 2 pontos;
- Se 1400 < **D** ≤ 2000, a cesta vale 3 pontos.

A organização da OIBR precisa de ajuda para automatizar o placar do jogo. Dado o valor da distância **D**, você deve escrever um programa para calcular o número de pontos do lançamento.

## **Entrada**

A primeira e única linha da entrada contém um inteiro **D** (0 ≤ **D** ≤ 2000) indicando a distância do robô para o início da quadra, em centímetros, no momento do lançamento.

## **Saída**

Seu programa deve produzir uma única linha, contendo um inteiro, 1, 2 ou 3, indicando a pontuação do lançamento.


1720

250

1400

3

1

2
"""

D = int(input())

if D <= 800:
    print(1)
elif D <= 1400:
    print(2)
else:
    print(3)